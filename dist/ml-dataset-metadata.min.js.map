{"version":3,"file":"ml-dataset-metadata.min.js","sources":["../lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// import Matrix from 'ml-matrix';\n\n/**\n * create new metadata object from 2D array\n * @param {Array} values - a 2d array with metadata values\n * @param {Object} [options]\n * @param {Array} [options.headers=[...Array(columns).keys()]] - an array with metadata headers\n * @param {Array} [options.IDs=[...Array(rows).keys()]] - an array with IDs\n */\nclass METADATA {\n  constructor(values, options = {}) {\n    let { columns,\n      rows } = [];\n\n    if (values === true) {\n      const metadata = options;\n      this.headers = metadata.headers;\n      this.IDs = metadata.IDs;\n      this.values = options.values;\n    } else {\n      columns = values.length;\n      rows = values[0].length;\n      this.values = values;\n      let {\n        headers = [...Array(columns).keys()].map((x) => (x + 1).toString()),\n        IDs = [...Array(rows).keys()].map((x) => (x + 1).toString())\n      } = options;\n\n      this.headers = headers;\n      this.IDs = IDs;\n    }\n  }\n\n  /**\n   * load metadata\n   * @param {Boolean} [metadata=true] - a boolean\n   * @param {Object} [options]\n   * @param {JSON} [options.metadata] - a metadata object\n   * @return {METADATA} - a metdata object\n   */\n  static load(metadata) {\n    if (typeof metadata.name !== 'string') {\n      throw new TypeError('metadata must have a name property');\n    }\n    if (metadata.name !== 'metadata') {\n      throw new RangeError(`invalid model: ${metadata.name}`);\n    }\n    return new METADATA(true, metadata);\n  }\n\n  /**\n   * save metadata to JSON\n   * @return {JSON} - a JSON with metadata\n   */\n  toJSON() {\n    return {\n      name: 'metadata',\n      headers: this.headers,\n      IDs: this.IDs,\n      values: this.values,\n    };\n  }\n\n  /**\n     * listMetadata\n     * @return {Array} - an array with headers\n     */\n  list() {\n    return this.headers;\n  }\n\n  /**\n     * add metadata\n     * @param {Array} value - an array with metadata\n     * @param {String} [by = 'column'] - select by row or by column\n     * @param {Object} [options]\n     * @param {String} [options.header] - a header for new metadata\n     */\n  append(values, by = 'column', options = {}) {\n    if (by === 'column') {\n      let { header = (this.headers.length + 1)\n        .toString() } = options;\n\n      if (typeof (header) !== 'string') {\n        console.warn('header was coerced to string');\n        header = header.toString();\n      }\n\n      if (this.headers.includes(header)) {\n        throw new Error('this header already exist');\n      }\n\n      if (values.length === this.values[0].length) {\n        this.values.push(values);\n        this.headers.push(header);\n      } else {\n        throw new Error('dimension doesn\\'t match');\n      }\n    } else if (by === 'row') {\n      let { ID = (this.IDs.length + 1)\n        .toString() } = options;\n\n      if (typeof (ID) !== 'string') {\n        console.warn('ID was coerced to string');\n        ID = ID.toString();\n      }\n\n      if (this.IDs.includes(ID)) {\n        throw new Error('this ID already exist');\n      }\n\n      if (values.length === this.values.length) {\n        this.values.map((x, idx) => x.push(values[idx]));\n        this.IDs.push(ID);\n      } else {\n        throw new Error('dimension doesn\\'t match');\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * remove row or column by index or name\n   * @param {any} index - an index or a column/row name\n   * @param {String} [by = 'row'] - select by row or by column\n   */\n  remove(index, by = 'row') {\n    if (typeof index !== 'object') {\n      index = [index];\n    }\n    if (by === 'column') {\n      index.forEach((el, idx) => {\n        if (typeof (el) === 'number') {\n          index[idx] = this.headers[el];\n        }\n      });\n      index.forEach((el, idx) => {\n        let id = this.headers.indexOf(index[idx]);\n        if (id > -1) {\n          this.headers.splice(id, 1);\n          this.values.splice(id, 1);\n        }\n      });\n    } else if (by === 'row') {\n      index.forEach((el, idx) => {\n        if (typeof el === 'number') {\n          index[idx] = this.IDs[el];\n        }\n      });\n      index.forEach((el, idx) => {\n        let id = this.IDs.indexOf(index[idx]);\n        if (id > -1) {\n          this.IDs.splice(id, 1);\n          this.values.map((x) => x.splice(id, 1));\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n     *\n     * @param {String} title - a title\n     * @return {Object} return { title, groupIDs, nClass, classVector, classFactor, classMatrix }\n     */\n  get(header) {\n    let index = this.headers.indexOf(header);\n    let classVector = this.values[index];\n\n    return classVector;\n  }\n\n  summary(header) {\n    let index = this.headers.indexOf(header);\n    let classVector = this.values[index];\n\n    let nObs = classVector.length;\n    let type = typeof (classVector[0]);\n    let counts = {};\n    switch (type) {\n      case 'string':\n        counts = summaryAClass(classVector);\n        break;\n      case 'number':\n        classVector = classVector.map((x) => x.toString());\n        counts = summaryAClass(classVector);\n        break;\n    }\n    let groupIDs = Object.keys(counts);\n    let nClass = groupIDs.length;\n    // let classFactor = classVector.map((x) => groupIDs.indexOf(x));\n\n    return { class: header, groups: counts, nObs, nClass };\n  }\n\n  sample(header, options = {}) {\n    const { fraction = 0.8 } = options;\n    let classVector = this.get(header, 'string');\n    let { trainIndex, testIndex, mask } = sampleAClass(classVector, fraction);\n\n    return {\n      trainIndex,\n      testIndex,\n      mask,\n      classVector\n    };\n  }\n}\n\nfunction summaryAClass(classVector) {\n  let counts = {};\n  classVector.forEach((x) => {\n    counts[x] = (counts[x] || 0) + 1;\n  });\n  return counts;\n}\n\nfunction sampleAClass(classVector, fraction) {\n  // sort the vector\n  let classVectorSorted = JSON.parse(JSON.stringify(classVector));\n  let result = Array.from(Array(classVectorSorted.length).keys())\n    .sort((a, b) => (classVectorSorted[a] < classVectorSorted[b] ? -1 :\n      (classVectorSorted[b] < classVectorSorted[a]) | 0));\n  classVectorSorted.sort((a, b) => (a < b ? -1 : (b < a) | 0));\n\n  // counts the class elements\n  let counts = summaryAClass(classVectorSorted);\n  console.log('counts', counts);\n  // pick a few per class\n  let indexOfSelected = [];\n  Object.keys(counts).forEach((e, i) => {\n    let shift = [];\n    Object.values(counts).reduce((a, c, i) => shift[i] = a + c, 0);\n    console.log(shift);\n    let arr = [...Array(counts[e]).keys()];\n\n    let r = [];\n    for (let i = 0; i < Math.floor(counts[e] * fraction); i++) {\n      let n = arr[Math.floor(Math.random() * arr.length)];\n      r.push(n);\n      let ind = arr.indexOf(n);\n      arr.splice(ind, 1);\n    }\n\n    if (i === 0) {\n      indexOfSelected = indexOfSelected.concat(r);\n    } else {\n      indexOfSelected = indexOfSelected\n        .concat(r.map((x) => x + shift[i - 1]));\n    }\n  });\n\n  // sort back the index\n  let trainIndex = [];\n  indexOfSelected.forEach((e) => trainIndex.push(result[e]));\n\n  let testIndex = [];\n  let mask = [];\n  classVector.forEach((el, idx) => {\n    if (trainIndex.includes(idx)) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n      testIndex.push(idx);\n    }\n  });\n  return { trainIndex, testIndex, mask };\n}\n\nexports.METADATA = METADATA;\n"],"names":["Object","defineProperty","exports","value","METADATA","constructor","values","options","columns","rows","metadata","headers","IDs","length","Array","keys","map","x","toString","name","TypeError","RangeError","toJSON","this","list","append","by","header","console","warn","includes","Error","push","ID","idx","remove","index","forEach","el","id","indexOf","splice","get","summary","classVector","nObs","counts","summaryAClass","class","groups","nClass","sample","fraction","trainIndex","testIndex","mask","classVectorSorted","JSON","parse","stringify","result","from","sort","a","b","log","indexOfSelected","e","i","shift","reduce","c","arr","r","Math","floor","n","random","ind","concat","sampleAClass"],"mappings":"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"}